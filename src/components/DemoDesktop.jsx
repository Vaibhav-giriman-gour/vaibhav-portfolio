/*
      Auto-generated by: https://github.com/pmndrs/gltfjsx
      Author: re1monsen (https://sketchfab.com/re1monsen)
      License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
      Source: https://sketchfab.com/3d-models/monitor-iii-fb119750ac4f4b1e89b4be7c870b4eb2
      Title: Monitor III
      */

import React, { useRef, useEffect, useState, useMemo } from "react";
import { useGLTF, useVideoTexture } from "@react-three/drei";
import * as THREE from "three";
import { useGSAP } from "@gsap/react";
import { gsap } from "gsap";
const DemoDesktop = (props) => {
  const group = useRef();
  const screenRef = useRef();
  const { nodes, materials } = useGLTF("/models/demoDesktop2.glb");
  const texture = useVideoTexture(
    props.texture || "/textures/project/crux-report-app2.mp4"
  );
  const screenMaterial = useMemo(() => {
    const mat = new THREE.MeshBasicMaterial({ map: texture });
    mat.map.encoding = THREE.sRGBEncoding;
    mat.map.wrapS = THREE.ClampToEdgeWrapping;
    mat.map.wrapT = THREE.ClampToEdgeWrapping;
    mat.map.repeat.set(-1, 1); // No flip
    mat.map.offset.set(1, 0); // No shift
    mat.needsUpdate = true;
    // mat.map.repeat.set(-1, 1); // Flip horizontally
    // mat.map.offset.set(1, 0);

    return mat;
  }, [texture]);
  const [videoAspect, setVideoAspect] = useState(16 / 9); // Default aspect

  // Get aspect ratio when metadata loads
  useEffect(() => {
    if (texture?.image instanceof HTMLVideoElement) {
      const video = texture.image;
      const onLoaded = () => {
        setVideoAspect(video.videoWidth / video.videoHeight);
      };
      video.addEventListener("loadedmetadata", onLoaded);
      return () => video.removeEventListener("loadedmetadata", onLoaded);
    }
  }, [texture]);

  //  To change the video from upside down to normal
  useEffect(() => {
    if (texture) {
      texture.flipY = false;
    }
  }, [texture]);

  //  To have the Animaton on the load
  useEffect(() => {
    if (!group.current) return;

    group.current.rotation.y = Math.PI / 2;

    const tl = gsap.timeline();
    tl.to(group.current.rotation, {
      y: 0,
      duration: 2,
      ease: "power3.out",
    });

    return () => tl.kill(); // Clean up to prevent buildup
  }, [texture]);

  return (
    <group ref={group} {...props} dispose={null}>
      <group rotation={[-Math.PI / 2, 0, 0]} scale={0.026}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.monitor_low_monitor_0.geometry}
            material={materials.monitor}
            position={[0, 2.588, 7.366]}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.monitor007_low_monitor_0.geometry}
            material={materials.monitor}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.monitor001_low_monitor_0.geometry}
            material={materials.monitor}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
          <mesh
            ref={screenRef}
            castShadow
            receiveShadow
            geometry={nodes.monitor002_low_monitor_0.geometry}
            material={screenMaterial}
            rotation={[-Math.PI / 2, 0, 0]}
            position={[0, 2.58, 0]} // Adjust to exactly match the screen
            scale={[
              100 * videoAspect > 100 ? 100 : 100 * videoAspect,
              100,
              100,
            ]}
          ></mesh>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.monitor003_low_monitor_0.geometry}
            material={materials.monitor}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.monitor004_low_monitor_0.geometry}
            material={materials.monitor}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.monitor005_low_monitor_0.geometry}
            material={materials.monitor}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.monitor006_low_monitor_0.geometry}
            material={materials.monitor}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />

          <mesh
            castShadow
            receiveShadow
            geometry={nodes.monitor008_low_monitor_0.geometry}
            material={materials.monitor}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.monitor009_low_monitor_0.geometry}
            material={materials.monitor}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.g__low_ground_0.geometry}
            material={materials.ground}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
        </group>
      </group>
    </group>
  );
};

useGLTF.preload("/models/demoDesktop2.glb");

export default DemoDesktop;
